// @generated by protobuf-ts 2.9.4 with parameter long_type_number,server_generic
// @generated from protobuf file "rpc.proto" (syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Job } from "./Protocol";
import { JobParam } from "./Protocol";
import { JobInput } from "./Protocol";
/**
 * @generated from protobuf message RpcRequestJob
 */
export interface RpcRequestJob {
    /**
     * @generated from protobuf field: string runOn = 1;
     */
    runOn: string;
    /**
     * @generated from protobuf field: uint64 maxDuration = 2;
     */
    maxDuration: number;
    /**
     * @generated from protobuf field: repeated JobInput input = 3;
     */
    input: JobInput[];
    /**
     * @generated from protobuf field: repeated JobParam param = 4;
     */
    param: JobParam[];
    /**
     * @generated from protobuf field: string customerPrivateKey = 5;
     */
    customerPrivateKey: string;
    /**
     * @generated from protobuf field: string description = 6;
     */
    description: string;
}
/**
 * @generated from protobuf message RpcGetJob
 */
export interface RpcGetJob {
    /**
     * @generated from protobuf field: string jobId = 1;
     */
    jobId: string;
}
/**
 * @generated from protobuf message RpcGetPendingJobs
 */
export interface RpcGetPendingJobs {
    /**
     * @generated from protobuf field: optional string filterByRunOn = 1;
     */
    filterByRunOn?: string;
    /**
     * @generated from protobuf field: optional string filterByCustomer = 2;
     */
    filterByCustomer?: string;
    /**
     * @generated from protobuf field: optional string filterByDescription = 3;
     */
    filterByDescription?: string;
    /**
     * @generated from protobuf field: optional string filterById = 4;
     */
    filterById?: string;
}
/**
 * @generated from protobuf message PendingJobs
 */
export interface PendingJobs {
    /**
     * @generated from protobuf field: repeated Job jobs = 1;
     */
    jobs: Job[];
}
/**
 * @generated from protobuf message RpcIsJobDone
 */
export interface RpcIsJobDone {
    /**
     * @generated from protobuf field: bool isDone = 1;
     */
    isDone: boolean;
}
/**
 * @generated from protobuf message RpcAcceptJob
 */
export interface RpcAcceptJob {
    /**
     * @generated from protobuf field: string jobId = 1;
     */
    jobId: string;
}
/**
 * @generated from protobuf message RpcCancelJob
 */
export interface RpcCancelJob {
    /**
     * @generated from protobuf field: string jobId = 1;
     */
    jobId: string;
    /**
     * @generated from protobuf field: string reason = 2;
     */
    reason: string;
}
/**
 * @generated from protobuf message RpcJobOutput
 */
export interface RpcJobOutput {
    /**
     * @generated from protobuf field: string jobId = 1;
     */
    jobId: string;
    /**
     * @generated from protobuf field: string output = 2;
     */
    output: string;
}
/**
 * @generated from protobuf message RpcJobComplete
 */
export interface RpcJobComplete {
    /**
     * @generated from protobuf field: string jobId = 1;
     */
    jobId: string;
    /**
     * @generated from protobuf field: string output = 2;
     */
    output: string;
    /**
     * @generated from protobuf field: optional string info = 3;
     */
    info?: string;
}
/**
 * @generated from protobuf message RpcJobLog
 */
export interface RpcJobLog {
    /**
     * @generated from protobuf field: string jobId = 1;
     */
    jobId: string;
    /**
     * @generated from protobuf field: string log = 2;
     */
    log: string;
}
/**
 * @generated from protobuf message RpcSendSignedEventRequest
 */
export interface RpcSendSignedEventRequest {
    /**
     * @generated from protobuf field: string parentJob = 1;
     */
    parentJob: string;
    /**
     * @generated from protobuf field: string event = 2;
     */
    event: string;
}
/**
 * @generated from protobuf message RpcSubscribeToEventsRequest
 */
export interface RpcSubscribeToEventsRequest {
    /**
     * @generated from protobuf field: string parentJob = 1;
     */
    parentJob: string;
    /**
     * @generated from protobuf field: repeated string filters = 2;
     */
    filters: string[];
}
/**
 * @generated from protobuf message RpcSubscribeToEventsResponse
 */
export interface RpcSubscribeToEventsResponse {
    /**
     * @generated from protobuf field: string parentJob = 1;
     */
    parentJob: string;
    /**
     * @generated from protobuf field: string subscriptionId = 2;
     */
    subscriptionId: string;
}
/**
 * @generated from protobuf message RpcGetEventsRequest
 */
export interface RpcGetEventsRequest {
    /**
     * @generated from protobuf field: string parentJob = 1;
     */
    parentJob: string;
    /**
     * @generated from protobuf field: string subscriptionId = 2;
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: uint32 limit = 3;
     */
    limit: number; // optional : 0 or unset means no limit
}
/**
 * @generated from protobuf message RpcGetEventsResponse
 */
export interface RpcGetEventsResponse {
    /**
     * @generated from protobuf field: string parentJob = 1;
     */
    parentJob: string;
    /**
     * @generated from protobuf field: uint32 count = 2;
     */
    count: number;
    /**
     * @generated from protobuf field: string subscriptionId = 3;
     */
    subscriptionId: string;
    /**
     * @generated from protobuf field: repeated string events = 4;
     */
    events: string[];
}
/**
 * @generated from protobuf message RpcSendSignedEventResponse
 */
export interface RpcSendSignedEventResponse {
    /**
     * @generated from protobuf field: string parentJob = 1;
     */
    parentJob: string;
    /**
     * @generated from protobuf field: bool success = 2;
     */
    success: boolean;
}
/**
 * @generated from protobuf message RpcUnsubscribeToEventsRequest
 */
export interface RpcUnsubscribeToEventsRequest {
    /**
     * @generated from protobuf field: string parentJob = 1;
     */
    parentJob: string;
    /**
     * @generated from protobuf field: string subscriptionId = 2;
     */
    subscriptionId: string;
}
/**
 * @generated from protobuf message RpcUnsubscribeToEventsResponse
 */
export interface RpcUnsubscribeToEventsResponse {
    /**
     * @generated from protobuf field: bool success = 1;
     */
    success: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class RpcRequestJob$Type extends MessageType<RpcRequestJob> {
    constructor() {
        super("RpcRequestJob", [
            { no: 1, name: "runOn", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "maxDuration", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "input", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => JobInput },
            { no: 4, name: "param", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => JobParam },
            { no: 5, name: "customerPrivateKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcRequestJob>): RpcRequestJob {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runOn = "";
        message.maxDuration = 0;
        message.input = [];
        message.param = [];
        message.customerPrivateKey = "";
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<RpcRequestJob>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcRequestJob): RpcRequestJob {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string runOn */ 1:
                    message.runOn = reader.string();
                    break;
                case /* uint64 maxDuration */ 2:
                    message.maxDuration = reader.uint64().toNumber();
                    break;
                case /* repeated JobInput input */ 3:
                    message.input.push(JobInput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated JobParam param */ 4:
                    message.param.push(JobParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string customerPrivateKey */ 5:
                    message.customerPrivateKey = reader.string();
                    break;
                case /* string description */ 6:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcRequestJob, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string runOn = 1; */
        if (message.runOn !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.runOn);
        /* uint64 maxDuration = 2; */
        if (message.maxDuration !== 0)
            writer.tag(2, WireType.Varint).uint64(message.maxDuration);
        /* repeated JobInput input = 3; */
        for (let i = 0; i < message.input.length; i++)
            JobInput.internalBinaryWrite(message.input[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated JobParam param = 4; */
        for (let i = 0; i < message.param.length; i++)
            JobParam.internalBinaryWrite(message.param[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string customerPrivateKey = 5; */
        if (message.customerPrivateKey !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.customerPrivateKey);
        /* string description = 6; */
        if (message.description !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcRequestJob
 */
export const RpcRequestJob = new RpcRequestJob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcGetJob$Type extends MessageType<RpcGetJob> {
    constructor() {
        super("RpcGetJob", [
            { no: 1, name: "jobId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcGetJob>): RpcGetJob {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = "";
        if (value !== undefined)
            reflectionMergePartial<RpcGetJob>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcGetJob): RpcGetJob {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string jobId */ 1:
                    message.jobId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcGetJob, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string jobId = 1; */
        if (message.jobId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.jobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcGetJob
 */
export const RpcGetJob = new RpcGetJob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcGetPendingJobs$Type extends MessageType<RpcGetPendingJobs> {
    constructor() {
        super("RpcGetPendingJobs", [
            { no: 1, name: "filterByRunOn", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "filterByCustomer", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "filterByDescription", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "filterById", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcGetPendingJobs>): RpcGetPendingJobs {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RpcGetPendingJobs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcGetPendingJobs): RpcGetPendingJobs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string filterByRunOn */ 1:
                    message.filterByRunOn = reader.string();
                    break;
                case /* optional string filterByCustomer */ 2:
                    message.filterByCustomer = reader.string();
                    break;
                case /* optional string filterByDescription */ 3:
                    message.filterByDescription = reader.string();
                    break;
                case /* optional string filterById */ 4:
                    message.filterById = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcGetPendingJobs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string filterByRunOn = 1; */
        if (message.filterByRunOn !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.filterByRunOn);
        /* optional string filterByCustomer = 2; */
        if (message.filterByCustomer !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.filterByCustomer);
        /* optional string filterByDescription = 3; */
        if (message.filterByDescription !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.filterByDescription);
        /* optional string filterById = 4; */
        if (message.filterById !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.filterById);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcGetPendingJobs
 */
export const RpcGetPendingJobs = new RpcGetPendingJobs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingJobs$Type extends MessageType<PendingJobs> {
    constructor() {
        super("PendingJobs", [
            { no: 1, name: "jobs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Job }
        ]);
    }
    create(value?: PartialMessage<PendingJobs>): PendingJobs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobs = [];
        if (value !== undefined)
            reflectionMergePartial<PendingJobs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingJobs): PendingJobs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Job jobs */ 1:
                    message.jobs.push(Job.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingJobs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Job jobs = 1; */
        for (let i = 0; i < message.jobs.length; i++)
            Job.internalBinaryWrite(message.jobs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PendingJobs
 */
export const PendingJobs = new PendingJobs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcIsJobDone$Type extends MessageType<RpcIsJobDone> {
    constructor() {
        super("RpcIsJobDone", [
            { no: 1, name: "isDone", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RpcIsJobDone>): RpcIsJobDone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isDone = false;
        if (value !== undefined)
            reflectionMergePartial<RpcIsJobDone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcIsJobDone): RpcIsJobDone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isDone */ 1:
                    message.isDone = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcIsJobDone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isDone = 1; */
        if (message.isDone !== false)
            writer.tag(1, WireType.Varint).bool(message.isDone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcIsJobDone
 */
export const RpcIsJobDone = new RpcIsJobDone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcAcceptJob$Type extends MessageType<RpcAcceptJob> {
    constructor() {
        super("RpcAcceptJob", [
            { no: 1, name: "jobId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcAcceptJob>): RpcAcceptJob {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = "";
        if (value !== undefined)
            reflectionMergePartial<RpcAcceptJob>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcAcceptJob): RpcAcceptJob {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string jobId */ 1:
                    message.jobId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcAcceptJob, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string jobId = 1; */
        if (message.jobId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.jobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcAcceptJob
 */
export const RpcAcceptJob = new RpcAcceptJob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcCancelJob$Type extends MessageType<RpcCancelJob> {
    constructor() {
        super("RpcCancelJob", [
            { no: 1, name: "jobId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcCancelJob>): RpcCancelJob {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = "";
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<RpcCancelJob>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcCancelJob): RpcCancelJob {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string jobId */ 1:
                    message.jobId = reader.string();
                    break;
                case /* string reason */ 2:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcCancelJob, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string jobId = 1; */
        if (message.jobId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.jobId);
        /* string reason = 2; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcCancelJob
 */
export const RpcCancelJob = new RpcCancelJob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcJobOutput$Type extends MessageType<RpcJobOutput> {
    constructor() {
        super("RpcJobOutput", [
            { no: 1, name: "jobId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "output", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcJobOutput>): RpcJobOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = "";
        message.output = "";
        if (value !== undefined)
            reflectionMergePartial<RpcJobOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcJobOutput): RpcJobOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string jobId */ 1:
                    message.jobId = reader.string();
                    break;
                case /* string output */ 2:
                    message.output = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcJobOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string jobId = 1; */
        if (message.jobId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.jobId);
        /* string output = 2; */
        if (message.output !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.output);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcJobOutput
 */
export const RpcJobOutput = new RpcJobOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcJobComplete$Type extends MessageType<RpcJobComplete> {
    constructor() {
        super("RpcJobComplete", [
            { no: 1, name: "jobId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "output", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "info", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcJobComplete>): RpcJobComplete {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = "";
        message.output = "";
        if (value !== undefined)
            reflectionMergePartial<RpcJobComplete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcJobComplete): RpcJobComplete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string jobId */ 1:
                    message.jobId = reader.string();
                    break;
                case /* string output */ 2:
                    message.output = reader.string();
                    break;
                case /* optional string info */ 3:
                    message.info = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcJobComplete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string jobId = 1; */
        if (message.jobId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.jobId);
        /* string output = 2; */
        if (message.output !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.output);
        /* optional string info = 3; */
        if (message.info !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.info);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcJobComplete
 */
export const RpcJobComplete = new RpcJobComplete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcJobLog$Type extends MessageType<RpcJobLog> {
    constructor() {
        super("RpcJobLog", [
            { no: 1, name: "jobId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcJobLog>): RpcJobLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = "";
        message.log = "";
        if (value !== undefined)
            reflectionMergePartial<RpcJobLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcJobLog): RpcJobLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string jobId */ 1:
                    message.jobId = reader.string();
                    break;
                case /* string log */ 2:
                    message.log = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcJobLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string jobId = 1; */
        if (message.jobId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.jobId);
        /* string log = 2; */
        if (message.log !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.log);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcJobLog
 */
export const RpcJobLog = new RpcJobLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcSendSignedEventRequest$Type extends MessageType<RpcSendSignedEventRequest> {
    constructor() {
        super("RpcSendSignedEventRequest", [
            { no: 1, name: "parentJob", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "event", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcSendSignedEventRequest>): RpcSendSignedEventRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parentJob = "";
        message.event = "";
        if (value !== undefined)
            reflectionMergePartial<RpcSendSignedEventRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcSendSignedEventRequest): RpcSendSignedEventRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parentJob */ 1:
                    message.parentJob = reader.string();
                    break;
                case /* string event */ 2:
                    message.event = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcSendSignedEventRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parentJob = 1; */
        if (message.parentJob !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parentJob);
        /* string event = 2; */
        if (message.event !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.event);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcSendSignedEventRequest
 */
export const RpcSendSignedEventRequest = new RpcSendSignedEventRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcSubscribeToEventsRequest$Type extends MessageType<RpcSubscribeToEventsRequest> {
    constructor() {
        super("RpcSubscribeToEventsRequest", [
            { no: 1, name: "parentJob", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "filters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcSubscribeToEventsRequest>): RpcSubscribeToEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parentJob = "";
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<RpcSubscribeToEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcSubscribeToEventsRequest): RpcSubscribeToEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parentJob */ 1:
                    message.parentJob = reader.string();
                    break;
                case /* repeated string filters */ 2:
                    message.filters.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcSubscribeToEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parentJob = 1; */
        if (message.parentJob !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parentJob);
        /* repeated string filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.filters[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcSubscribeToEventsRequest
 */
export const RpcSubscribeToEventsRequest = new RpcSubscribeToEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcSubscribeToEventsResponse$Type extends MessageType<RpcSubscribeToEventsResponse> {
    constructor() {
        super("RpcSubscribeToEventsResponse", [
            { no: 1, name: "parentJob", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscriptionId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcSubscribeToEventsResponse>): RpcSubscribeToEventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parentJob = "";
        message.subscriptionId = "";
        if (value !== undefined)
            reflectionMergePartial<RpcSubscribeToEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcSubscribeToEventsResponse): RpcSubscribeToEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parentJob */ 1:
                    message.parentJob = reader.string();
                    break;
                case /* string subscriptionId */ 2:
                    message.subscriptionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcSubscribeToEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parentJob = 1; */
        if (message.parentJob !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parentJob);
        /* string subscriptionId = 2; */
        if (message.subscriptionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subscriptionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcSubscribeToEventsResponse
 */
export const RpcSubscribeToEventsResponse = new RpcSubscribeToEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcGetEventsRequest$Type extends MessageType<RpcGetEventsRequest> {
    constructor() {
        super("RpcGetEventsRequest", [
            { no: 1, name: "parentJob", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscriptionId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RpcGetEventsRequest>): RpcGetEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parentJob = "";
        message.subscriptionId = "";
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<RpcGetEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcGetEventsRequest): RpcGetEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parentJob */ 1:
                    message.parentJob = reader.string();
                    break;
                case /* string subscriptionId */ 2:
                    message.subscriptionId = reader.string();
                    break;
                case /* uint32 limit */ 3:
                    message.limit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcGetEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parentJob = 1; */
        if (message.parentJob !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parentJob);
        /* string subscriptionId = 2; */
        if (message.subscriptionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subscriptionId);
        /* uint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).uint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcGetEventsRequest
 */
export const RpcGetEventsRequest = new RpcGetEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcGetEventsResponse$Type extends MessageType<RpcGetEventsResponse> {
    constructor() {
        super("RpcGetEventsResponse", [
            { no: 1, name: "parentJob", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "subscriptionId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "events", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcGetEventsResponse>): RpcGetEventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parentJob = "";
        message.count = 0;
        message.subscriptionId = "";
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<RpcGetEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcGetEventsResponse): RpcGetEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parentJob */ 1:
                    message.parentJob = reader.string();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                case /* string subscriptionId */ 3:
                    message.subscriptionId = reader.string();
                    break;
                case /* repeated string events */ 4:
                    message.events.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcGetEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parentJob = 1; */
        if (message.parentJob !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parentJob);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).uint32(message.count);
        /* string subscriptionId = 3; */
        if (message.subscriptionId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subscriptionId);
        /* repeated string events = 4; */
        for (let i = 0; i < message.events.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.events[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcGetEventsResponse
 */
export const RpcGetEventsResponse = new RpcGetEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcSendSignedEventResponse$Type extends MessageType<RpcSendSignedEventResponse> {
    constructor() {
        super("RpcSendSignedEventResponse", [
            { no: 1, name: "parentJob", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RpcSendSignedEventResponse>): RpcSendSignedEventResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parentJob = "";
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<RpcSendSignedEventResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcSendSignedEventResponse): RpcSendSignedEventResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parentJob */ 1:
                    message.parentJob = reader.string();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcSendSignedEventResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parentJob = 1; */
        if (message.parentJob !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parentJob);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcSendSignedEventResponse
 */
export const RpcSendSignedEventResponse = new RpcSendSignedEventResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcUnsubscribeToEventsRequest$Type extends MessageType<RpcUnsubscribeToEventsRequest> {
    constructor() {
        super("RpcUnsubscribeToEventsRequest", [
            { no: 1, name: "parentJob", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscriptionId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RpcUnsubscribeToEventsRequest>): RpcUnsubscribeToEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parentJob = "";
        message.subscriptionId = "";
        if (value !== undefined)
            reflectionMergePartial<RpcUnsubscribeToEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcUnsubscribeToEventsRequest): RpcUnsubscribeToEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parentJob */ 1:
                    message.parentJob = reader.string();
                    break;
                case /* string subscriptionId */ 2:
                    message.subscriptionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcUnsubscribeToEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parentJob = 1; */
        if (message.parentJob !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parentJob);
        /* string subscriptionId = 2; */
        if (message.subscriptionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subscriptionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcUnsubscribeToEventsRequest
 */
export const RpcUnsubscribeToEventsRequest = new RpcUnsubscribeToEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RpcUnsubscribeToEventsResponse$Type extends MessageType<RpcUnsubscribeToEventsResponse> {
    constructor() {
        super("RpcUnsubscribeToEventsResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RpcUnsubscribeToEventsResponse>): RpcUnsubscribeToEventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<RpcUnsubscribeToEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RpcUnsubscribeToEventsResponse): RpcUnsubscribeToEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RpcUnsubscribeToEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RpcUnsubscribeToEventsResponse
 */
export const RpcUnsubscribeToEventsResponse = new RpcUnsubscribeToEventsResponse$Type();
/**
 * @generated ServiceType for protobuf service NostrConnector
 */
export const NostrConnector = new ServiceType("NostrConnector", [
    { name: "requestJob", options: {}, I: RpcRequestJob, O: Job },
    { name: "getJob", options: {}, I: RpcGetJob, O: Job },
    { name: "getPendingJobs", options: {}, I: RpcGetPendingJobs, O: PendingJobs },
    { name: "isJobDone", options: {}, I: RpcGetJob, O: RpcIsJobDone },
    { name: "acceptJob", options: {}, I: RpcAcceptJob, O: Job },
    { name: "cancelJob", options: {}, I: RpcCancelJob, O: Job },
    { name: "outputForJob", options: {}, I: RpcJobOutput, O: Job },
    { name: "completeJob", options: {}, I: RpcJobComplete, O: Job },
    { name: "logForJob", options: {}, I: RpcJobLog, O: Job },
    { name: "sendSignedEvent", options: {}, I: RpcSendSignedEventRequest, O: RpcSendSignedEventResponse },
    { name: "subscribeToEvents", options: {}, I: RpcSubscribeToEventsRequest, O: RpcSubscribeToEventsResponse },
    { name: "unsubscribeToEvents", options: {}, I: RpcUnsubscribeToEventsRequest, O: RpcUnsubscribeToEventsResponse },
    { name: "getEvents", options: {}, I: RpcGetEventsRequest, O: RpcGetEventsResponse }
]);
